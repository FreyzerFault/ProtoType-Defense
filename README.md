# Prototype Defence

## Aclaraciones:

Más de un 90% de comentarios y nombres de variables/métodos están en inglés por pura inercia. Me manejo mejor llamando a ciertas variables por su nombre en inglés (center, position, tile, move,...) y no me gusta intercalarlo con el español si no es necesario. Además es bueno para practicar. Escribir todo en inglés es intencional, todo lo que hay en las carpetas src, tests y res y está escrito por mí.


## OpenGL Pipeline Framework

![OpenGL Pipeline](https://user-images.githubusercontent.com/72341309/115261897-50bf0780-a134-11eb-9e5e-406c372e2ac4.png)

Para facilitar la gestión de cada elemento (Texturas, Shaders,...) he creado Managers mediante los que controlar cada elemento de openGL.

El padre de todos es el WindowManager, el cual encapsula toda la pipeline de OpenGL y gestiona la creación de la ventana.

Los Tests son estructuras aparte de OpenGL con su framework independiente pero sirve como esqueleto del juego, con los que gestionar cada fase de la renderización, cálculos matemáticos y actualizaciones de variables en onUpdate(), Drawcalls, Shaders y MVPs matrices en OnRender(), y la interfaz en OnImGuiRender().

ImGui es otro framework con el que se crean interfaces similares a los de Java Swing. El código base es de [aquí](https://github.com/ocornut/imgui)

Y el Renderer es una simple herramienta para usar código de openGL encapsulado en una clase.

[![](https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXHJcblxyXG4gICAgV2luZG93TWFuYWdlci0-PitXaW5kb3dNYW5hZ2VyOiBDcmVhdGUgV2luZG93IGFuZCBDb250ZXh0XHJcbiAgICBXaW5kb3dNYW5hZ2VyLT4-K1JlbmRlcmVyOiBFbmFibGUgb3BlbkdMIEZsYWdzXHJcbiAgICBXaW5kb3dNYW5hZ2VyLT4-K0ltR3VpTWFuYWdlcjogU2V0dXAgKENyZWF0ZSBDb250ZXh0ICYgSW5pdGlhdGUpXHJcbiAgICBXaW5kb3dNYW5hZ2VyLT4-LVRlc3RNYW5hZ2VyOiBDcmVhdGUgVGVzdHNcclxuICAgIFRlc3RNYW5hZ2VyLT4-K0dhbWU6IEluaWNpYWxpemFyXHJcbiAgICBHYW1lLT4-K1NoYWRlck1hbmFnZXI6IEJpbmQgdG9kb3MgbG9zIHNoYWRlcnMgcXVlIG5lY2VzaXRlXHJcbiAgICBHYW1lLT4-K1RleHR1cmVNYW5hZ2VyOiBCaW5kIHRvZGFzIGxhcyB0ZXh0dXJhcyBxdWUgbmVjZXNpdGVcclxuICAgIEdhbWUtPj4tU2hhZGVyTWFuYWdlcjogc2V0VGV4dHVyZVNsb3RzKG51bVRleHR1cmVzKVxyXG4gICAgV2luZG93TWFuYWdlci0-PitXaW5kb3dNYW5hZ2VyOiBTdGFydFJlbmRlcmluZ0xvb3BcclxuICAgIGxvb3AgQ2FkYSBmcmFtZVxyXG4gICAgICAgIFdpbmRvd01hbmFnZXItPj4rSW1HdWlNYW5hZ2VyOiBTdGFydCBGcmFtZVxyXG4gICAgICAgIFdpbmRvd01hbmFnZXItPj5XaW5kb3dNYW5hZ2VyOiBDYWxjdWxhdGUgRGVsdGEgVGltZVxyXG4gICAgICAgIGFsdCBTaSBoYXkgdW4gVGVzdCBlbiBtYXJjaGFcclxuICAgICAgICAgICAgV2luZG93TWFuYWdlci0-PitUZXN0TWFuYWdlcjogT25VcGRhdGUoZGVsdGFUaW1lKVxyXG4gICAgICAgICAgICBXaW5kb3dNYW5hZ2VyLT4-K1Rlc3RNYW5hZ2VyOiBPblJlbmRlcigpXHJcbiAgICAgICAgICAgIFdpbmRvd01hbmFnZXItPj4rVGVzdE1hbmFnZXI6IE9uSW1HdWlSZW5kZXIoKVxyXG4gICAgICAgIGVuZFxyXG5cclxuICAgICAgICBXaW5kb3dNYW5hZ2VyLT4-LUltR3VpTWFuYWdlcjogRW5kIEZyYW1lXHJcbiAgICAgICAgXHJcbiAgICBlbmRcclxuXHJcbiAgICBXaW5kb3dNYW5hZ2VyLT4-K1dpbmRvd01hbmFnZXI6IFNodXRkb3duXHJcbiAgICBXaW5kb3dNYW5hZ2VyLT4-LUltR3VpTWFuYWdlcjogU2h1dGRvd24iLCJtZXJtYWlkIjp7InRoZW1lIjoiZm9yZXN0In0sInVwZGF0ZUVkaXRvciI6ZmFsc2V9)](https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXHJcblxyXG4gICAgV2luZG93TWFuYWdlci0-PitXaW5kb3dNYW5hZ2VyOiBDcmVhdGUgV2luZG93IGFuZCBDb250ZXh0XHJcbiAgICBXaW5kb3dNYW5hZ2VyLT4-K1JlbmRlcmVyOiBFbmFibGUgb3BlbkdMIEZsYWdzXHJcbiAgICBXaW5kb3dNYW5hZ2VyLT4-K0ltR3VpTWFuYWdlcjogU2V0dXAgKENyZWF0ZSBDb250ZXh0ICYgSW5pdGlhdGUpXHJcbiAgICBXaW5kb3dNYW5hZ2VyLT4-LVRlc3RNYW5hZ2VyOiBDcmVhdGUgVGVzdHNcclxuICAgIFRlc3RNYW5hZ2VyLT4-K0dhbWU6IEluaWNpYWxpemFyXHJcbiAgICBHYW1lLT4-K1NoYWRlck1hbmFnZXI6IEJpbmQgdG9kb3MgbG9zIHNoYWRlcnMgcXVlIG5lY2VzaXRlXHJcbiAgICBHYW1lLT4-K1RleHR1cmVNYW5hZ2VyOiBCaW5kIHRvZGFzIGxhcyB0ZXh0dXJhcyBxdWUgbmVjZXNpdGVcclxuICAgIEdhbWUtPj4tU2hhZGVyTWFuYWdlcjogc2V0VGV4dHVyZVNsb3RzKG51bVRleHR1cmVzKVxyXG4gICAgV2luZG93TWFuYWdlci0-PitXaW5kb3dNYW5hZ2VyOiBTdGFydFJlbmRlcmluZ0xvb3BcclxuICAgIGxvb3AgQ2FkYSBmcmFtZVxyXG4gICAgICAgIFdpbmRvd01hbmFnZXItPj4rSW1HdWlNYW5hZ2VyOiBTdGFydCBGcmFtZVxyXG4gICAgICAgIFdpbmRvd01hbmFnZXItPj5XaW5kb3dNYW5hZ2VyOiBDYWxjdWxhdGUgRGVsdGEgVGltZVxyXG4gICAgICAgIGFsdCBTaSBoYXkgdW4gVGVzdCBlbiBtYXJjaGFcclxuICAgICAgICAgICAgV2luZG93TWFuYWdlci0-PitUZXN0TWFuYWdlcjogT25VcGRhdGUoZGVsdGFUaW1lKVxyXG4gICAgICAgICAgICBXaW5kb3dNYW5hZ2VyLT4-K1Rlc3RNYW5hZ2VyOiBPblJlbmRlcigpXHJcbiAgICAgICAgICAgIFdpbmRvd01hbmFnZXItPj4rVGVzdE1hbmFnZXI6IE9uSW1HdWlSZW5kZXIoKVxyXG4gICAgICAgIGVuZFxyXG5cclxuICAgICAgICBXaW5kb3dNYW5hZ2VyLT4-LUltR3VpTWFuYWdlcjogRW5kIEZyYW1lXHJcbiAgICAgICAgXHJcbiAgICBlbmRcclxuXHJcbiAgICBXaW5kb3dNYW5hZ2VyLT4-K1dpbmRvd01hbmFnZXI6IFNodXRkb3duXHJcbiAgICBXaW5kb3dNYW5hZ2VyLT4-LUltR3VpTWFuYWdlcjogU2h1dGRvd24iLCJtZXJtYWlkIjp7InRoZW1lIjoiZm9yZXN0In0sInVwZGF0ZUVkaXRvciI6ZmFsc2V9)



# Game Design

## Structures:

![Game Structure](https://user-images.githubusercontent.com/72341309/115261919-561c5200-a134-11eb-87bf-85278bd80fd2.png)

## Objects:

![Game Design](https://user-images.githubusercontent.com/72341309/115261933-5a486f80-a134-11eb-94f0-553ef3693872.png)

#### Game Controller:
Controla el flujo del juego a lo largo de un FRAME

**OnUpdate( deltaTime )** contiene la lógica del juego, movimientos, colisiones y comportamientos de cada Entidad:
- Tower rota para apuntar al enemigo según su preferencia y dispara con una frecuencia
- Projectile se mueve según las propiedades que la torre le concedió tras su creación, y comprueba colisiones con enemigos.
- Enemy se mueve a lo largo del camino y recibe daño de los proyectiles.
- Path guarda información sobre los enemigos y calcula a qué enemigo deben apuntar las torres según su preferencia.


[![](https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXHJcblxyXG4gICAgcGFydGljaXBhbnQgR2FtZSBhcyBHYW1lIENvbnRyb2xsZXJcclxuXHJcbiAgICBwYXIgb25VcGRhdGUgcG9yIEZyYW1lXHJcblxyXG4gICAgICAgIGxvb3AgQ2FkYSBmcmFtZVxyXG5cclxuICAgICAgICAgICAgbG9vcCBDYWRhIHByb2plY3RpbGVcclxuXHJcbiAgICAgICAgICAgICAgICBhbHQgQ29saXNpb24gY29uIEVuZW1pZ29cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgR2FtZS0-PitQcm9qZWN0aWxlOiBEZWxldGVcclxuICAgICAgICAgICAgICAgICAgICBHYW1lLT4-K0VuZW15OiBnZXRIaXQoVG93ZXIgRG1nKVxyXG4gICAgICAgICAgICAgICAgICAgIEVuZW15LS0-Pi1HYW1lOiBMaWZlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGFsdCBMaWZlIDw9IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgR2FtZS0-PitFbmVteTogRGVsZXRlXHJcbiAgICAgICAgICAgICAgICAgICAgZW5kXHJcblxyXG4gICAgICAgICAgICAgICAgZWxzZSBObyBDb2xpc2lvbmFcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYWx0IEhvbW1pbmdcclxuICAgICAgICAgICAgICAgICAgICBUb3dlci0-PitQcm9qZWN0aWxlOiBHZXQgQWltZWQgRW5lbXlcclxuICAgICAgICAgICAgICAgICAgICAgICAgUHJvamVjdGlsZS0tPj4tUHJvamVjdGlsZTogTG9va0F0KEVuZW15KVxyXG4gICAgICAgICAgICAgICAgICAgIGVuZFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBHYW1lLT4-K1Byb2plY3RpbGU6IE1vdmVcclxuXHJcbiAgICAgICAgICAgICAgICBlbmRcclxuXHJcbiAgICAgICAgICAgIGVuZFxyXG5cclxuICAgICAgICAgICAgbG9vcCBDYWRhIFRvd2VyXHJcbiAgICAgICAgICAgICAgICBHYW1lLT4-K1Rvd2VyOiBBcHVudGFyIEVuZW1pZ29cclxuICAgICAgICAgICAgICAgIFRvd2VyLT4-K1BhdGg6IEdldCBGaXJzdC9MYXN0L1dlYWsvU3Ryb25nIEVuZW15XHJcbiAgICAgICAgICAgICAgICBQYXRoLS0-Pi1Ub3dlcjogQWltZWQgRW5lbXlcclxuICAgICAgICAgICAgICAgIFRvd2VyLS0-Pi1Ub3dlcjogTG9va0F0KEVuZW15IFBvc2l0aW9uKVxyXG4gICAgICAgICAgICBlbmRcclxuXHJcbiAgICAgICAgICAgIGxvb3AgQ2FkYSBFbmVteVxyXG4gICAgICAgICAgICAgICAgR2FtZS0-PitFbmVteTogTW92ZVxyXG4gICAgICAgICAgICBlbmRcclxuXHJcbiAgICAgICAgZW5kXHJcblxyXG4gICAgYW5kIG9uVXBkYXRlIHBvciBTaG9vdFRpbWVyXHJcbiAgICAgICAgbG9vcCBDYWRhIFRvd2VyXHJcbiAgICAgICAgICAgIGFsdCBTaG9vdFRpbWVyID49IDEgLyBUb3dlciBTcGVlZFxyXG4gICAgICAgICAgICAgICAgR2FtZS0-PitUb3dlcjogU2hvb3RcclxuICAgICAgICAgICAgZW5kXHJcbiAgICAgICAgZW5kXHJcbiAgICBlbmQiLCJtZXJtYWlkIjp7InRoZW1lIjoiZm9yZXN0In0sInVwZGF0ZUVkaXRvciI6ZmFsc2V9)](https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXHJcblxyXG4gICAgcGFydGljaXBhbnQgR2FtZSBhcyBHYW1lIENvbnRyb2xsZXJcclxuXHJcbiAgICBwYXIgb25VcGRhdGUgcG9yIEZyYW1lXHJcblxyXG4gICAgICAgIGxvb3AgQ2FkYSBmcmFtZVxyXG5cclxuICAgICAgICAgICAgbG9vcCBDYWRhIHByb2plY3RpbGVcclxuXHJcbiAgICAgICAgICAgICAgICBhbHQgQ29saXNpb24gY29uIEVuZW1pZ29cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgR2FtZS0-PitQcm9qZWN0aWxlOiBEZWxldGVcclxuICAgICAgICAgICAgICAgICAgICBHYW1lLT4-K0VuZW15OiBnZXRIaXQoVG93ZXIgRG1nKVxyXG4gICAgICAgICAgICAgICAgICAgIEVuZW15LS0-Pi1HYW1lOiBMaWZlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGFsdCBMaWZlIDw9IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgR2FtZS0-PitFbmVteTogRGVsZXRlXHJcbiAgICAgICAgICAgICAgICAgICAgZW5kXHJcblxyXG4gICAgICAgICAgICAgICAgZWxzZSBObyBDb2xpc2lvbmFcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYWx0IEhvbW1pbmdcclxuICAgICAgICAgICAgICAgICAgICBUb3dlci0-PitQcm9qZWN0aWxlOiBHZXQgQWltZWQgRW5lbXlcclxuICAgICAgICAgICAgICAgICAgICAgICAgUHJvamVjdGlsZS0tPj4tUHJvamVjdGlsZTogTG9va0F0KEVuZW15KVxyXG4gICAgICAgICAgICAgICAgICAgIGVuZFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBHYW1lLT4-K1Byb2plY3RpbGU6IE1vdmVcclxuXHJcbiAgICAgICAgICAgICAgICBlbmRcclxuXHJcbiAgICAgICAgICAgIGVuZFxyXG5cclxuICAgICAgICAgICAgbG9vcCBDYWRhIFRvd2VyXHJcbiAgICAgICAgICAgICAgICBHYW1lLT4-K1Rvd2VyOiBBcHVudGFyIEVuZW1pZ29cclxuICAgICAgICAgICAgICAgIFRvd2VyLT4-K1BhdGg6IEdldCBGaXJzdC9MYXN0L1dlYWsvU3Ryb25nIEVuZW15XHJcbiAgICAgICAgICAgICAgICBQYXRoLS0-Pi1Ub3dlcjogQWltZWQgRW5lbXlcclxuICAgICAgICAgICAgICAgIFRvd2VyLS0-Pi1Ub3dlcjogTG9va0F0KEVuZW15IFBvc2l0aW9uKVxyXG4gICAgICAgICAgICBlbmRcclxuXHJcbiAgICAgICAgICAgIGxvb3AgQ2FkYSBFbmVteVxyXG4gICAgICAgICAgICAgICAgR2FtZS0-PitFbmVteTogTW92ZVxyXG4gICAgICAgICAgICBlbmRcclxuXHJcbiAgICAgICAgZW5kXHJcblxyXG4gICAgYW5kIG9uVXBkYXRlIHBvciBTaG9vdFRpbWVyXHJcbiAgICAgICAgbG9vcCBDYWRhIFRvd2VyXHJcbiAgICAgICAgICAgIGFsdCBTaG9vdFRpbWVyID49IDEgLyBUb3dlciBTcGVlZFxyXG4gICAgICAgICAgICAgICAgR2FtZS0-PitUb3dlcjogU2hvb3RcclxuICAgICAgICAgICAgZW5kXHJcbiAgICAgICAgZW5kXHJcbiAgICBlbmQiLCJtZXJtYWlkIjp7InRoZW1lIjoiZm9yZXN0In0sInVwZGF0ZUVkaXRvciI6ZmFsc2V9)



**OnRender()** utiliza el framework de OpenGL para renderizar todas las entidades con su Sprite, y demás objetos:
- Sprite está formado por un Quad de 2 Triángulos con una textura encima
- Hitbox tiene las propiedades necesarias para detectar colisiones, pero también puede renderizarse su contorno
- Texture Manager es el encargado de importar todas las texturas y enlazarlas con uno de los 31 slots que openGL proporciona
- Shader Manager gestiona los Shaders importándolos y compilándolos al igual que las texturas, además de declarar uniforms y enlazarlos con el contexto de OpenGL.



[![](https://mermaid.ink/img/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXHJcblxyXG5wYXJ0aWNpcGFudCBHYW1lIGFzIEdhbWUgQ29udHJvbGxlclxyXG5wYXJ0aWNpcGFudCBTcHJpdGUgYXMgRW50aXR5IFNwcml0ZVxyXG5wYXJ0aWNpcGFudCBIaXRib3ggYXMgRW50aXR5IEhpdGJveFxyXG5wYXJ0aWNpcGFudCBUZXh0dXJlIGFzIFRleHR1cmUgTWFuYWdlclxyXG5wYXJ0aWNpcGFudCBTaGFkZXIgYXMgU2hhZGVyIE1hbmFnZXJcclxuXHJcbk5vdGUgbGVmdCBvZiBHYW1lIDogb25SZW5kZXIoKVxyXG5cclxuR2FtZS0-PitTaGFkZXIgOiBCaW5kIE1haW4gU2hhZGVyXHJcblxyXG5sb29wIENhZGEgVGV4dHVyYVxyXG4gICAgR2FtZS0-PitUZXh0dXJlIDogQmluZChzbG90KVxyXG5lbmRcclxuXHJcbk5vdGUgbGVmdCBvZiBHYW1lIDogU3ByaXRlIERyYXdpbmdcclxuXHJcbmxvb3AgQ2FkYSBFbnRpdHlcclxuXHJcbiAgICBHYW1lLT4-K1Nwcml0ZSA6IERyYXdcclxuICAgIFNwcml0ZS0-PitTaGFkZXIgOiBTRVQgTVZQIFVuaWZvcm0gPSBTcHJpdGUgTVZQICogZGVmYXVsdCBNVlBcclxuICAgIFNwcml0ZS0-Pi1TcHJpdGUgOiBnbERyYXcoKVxyXG5cclxuZW5kXHJcblxyXG5Ob3RlIGxlZnQgb2YgR2FtZSA6IEhpdGJveCBHcmlkIERyYXdpbmdcclxuXHJcbmxvb3AgQ2FkYSBFbnRpdHkgY29uIEhpdGJveFxyXG5cclxuICAgIEdhbWUtPj4rSGl0Ym94IDogRHJhdyBHcmlkXHJcbiAgICBIaXRib3gtPj4rU2hhZGVyIDogU0VUIE1WUCBVbmlmb3JtID0gSGl0Ym94IE1WUCAqIGRlZmF1bHQgTVZQXHJcbiAgICBIaXRib3gtPj4tSGl0Ym94IDogZ2xEcmF3KClcclxuXHJcbmVuZCIsIm1lcm1haWQiOnsidGhlbWUiOiJmb3Jlc3QifSwidXBkYXRlRWRpdG9yIjpmYWxzZX0)](https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoic2VxdWVuY2VEaWFncmFtXHJcblxyXG5wYXJ0aWNpcGFudCBHYW1lIGFzIEdhbWUgQ29udHJvbGxlclxyXG5wYXJ0aWNpcGFudCBTcHJpdGUgYXMgRW50aXR5IFNwcml0ZVxyXG5wYXJ0aWNpcGFudCBIaXRib3ggYXMgRW50aXR5IEhpdGJveFxyXG5wYXJ0aWNpcGFudCBUZXh0dXJlIGFzIFRleHR1cmUgTWFuYWdlclxyXG5wYXJ0aWNpcGFudCBTaGFkZXIgYXMgU2hhZGVyIE1hbmFnZXJcclxuXHJcbk5vdGUgbGVmdCBvZiBHYW1lIDogb25SZW5kZXIoKVxyXG5cclxuR2FtZS0-PitTaGFkZXIgOiBCaW5kIE1haW4gU2hhZGVyXHJcblxyXG5sb29wIENhZGEgVGV4dHVyYVxyXG4gICAgR2FtZS0-PitUZXh0dXJlIDogQmluZChzbG90KVxyXG5lbmRcclxuXHJcbk5vdGUgbGVmdCBvZiBHYW1lIDogU3ByaXRlIERyYXdpbmdcclxuXHJcbmxvb3AgQ2FkYSBFbnRpdHlcclxuXHJcbiAgICBHYW1lLT4-K1Nwcml0ZSA6IERyYXdcclxuICAgIFNwcml0ZS0-PitTaGFkZXIgOiBTRVQgTVZQIFVuaWZvcm0gPSBTcHJpdGUgTVZQICogZGVmYXVsdCBNVlBcclxuICAgIFNwcml0ZS0-Pi1TcHJpdGUgOiBnbERyYXcoKVxyXG5cclxuZW5kXHJcblxyXG5Ob3RlIGxlZnQgb2YgR2FtZSA6IEhpdGJveCBHcmlkIERyYXdpbmdcclxuXHJcbmxvb3AgQ2FkYSBFbnRpdHkgY29uIEhpdGJveFxyXG5cclxuICAgIEdhbWUtPj4rSGl0Ym94IDogRHJhdyBHcmlkXHJcbiAgICBIaXRib3gtPj4rU2hhZGVyIDogU0VUIE1WUCBVbmlmb3JtID0gSGl0Ym94IE1WUCAqIGRlZmF1bHQgTVZQXHJcbiAgICBIaXRib3gtPj4tSGl0Ym94IDogZ2xEcmF3KClcclxuXHJcbmVuZCIsIm1lcm1haWQiOnsidGhlbWUiOiJmb3Jlc3QifSwidXBkYXRlRWRpdG9yIjpmYWxzZX0)


## INTERACTUABILIDAD

Para gestionar los inputs he creado un InputManager donde tengo todos los callbacks asignados a los eventos de entrada. Por ahora solo está la pulsación de ratón.

Al pulsar click Izquierdo se coloca una torre en la tile donde está el cursor, o se selecciona si hay una. Esto permite cambiar, por ejemplo, la prioridad de apuntado, al Primero, Último, más Fuerte y más Débil.

El click Derecho vende la torre eliminándola.



## ENEMIGOS

Siguen la dirección de la tile en la que están. Para hacerlo más orgánico añadí un factor aleatorio cada vez que deben cambiar de dirección.
Si la Tile en la que entran tiene una dirección distinta, van a calcular una posición cerca del centro de forma aleatoria donde cambiará de dirección. El offset de la posición desde el centro es aleatorio. Y no tiene que ser precisamente en esa posición, sino que hay un espacio del (tamaño de la tile / 10) designado para que cambien de dirección.

<img width="107" alt="cambio de direccion enemigo" src="https://user-images.githubusercontent.com/72341309/120074379-dec7cf80-c09c-11eb-861e-ad40d88bdbb3.PNG">


## TORRETAS

Se colocan en Plataformas y pueden ser seleccionadas. Existe la capacidad de añadir torres de distinto tipo que no he implentando, de forma que cada una difiera en las estadísticas de daño, rango, etc.

Su funcionamiento es sencillo, apuntan a un enemigo según su prioridad y será el Path el que elegirá el enemigo ideal, ya que tiene la capacidad de ordenarlos y consultar sus stats.
Por ejemplo, para el primer enemigo, ordenará los enemigos en una Lista, primero ordenándolos según su Tile, ya que a la hora de la creación del camino, las Tiles se guardan ordenadas desde un principio. Para las Tiles que puedan tener más de un enemigo se realiza una comparación que depende de la Dirección de la Tile. Por ejemplo, si es una Tile que va para la derecha, los enemigos se ordenan según su coordenada X.

Para disparar utilizo un Timer que gestiono manualmente. Según el deltaTime el Timer aumenta, y cuando supere el periodo que tiene que esperar entre disparos (1 / Speed), reinicia el Timer y se produce un Disparo.
Al disparar se crea un proyectil en la posición de la Torreta con su misma dirección.
Además he implementado un método de apuntado predictivo en el que según la dirección del enemigo, la torreta va a apuntar un pelín delante del enemigo para tener margen.

![predictive](https://user-images.githubusercontent.com/72341309/123550671-f44d1980-d76e-11eb-810d-1c0abb737ac1.png)



## PROYECTILES

Se diferencian de si son Homing (guiado). Si no lo son su trayectoria no cambia y se mueven según su velocidad.
Si son guiados he implementado un método de seguimiento que produce unas trayectorias más reales que simplemente hacer que apunte directamente al enemigo.
Calculo el ángulo entre el vector dirección del proyectil y el vector que va del proyectil al enemigo. Si es mayor de un umbral, girará solamente ese umbral, para evitar giros bruscos.

![homing](https://user-images.githubusercontent.com/72341309/123550741-4c841b80-d76f-11eb-88b4-0f394f51eaec.png)


La interacción al golpear un enemigo tampoco es trivial. Ya que cada frame estoy comprobando colisiones, si un proyectil atraviesa un enemigo va a tardar varios frames más en dejar de colisionar, y no sería un comportamiento coherente ya que golpearía tantas veces como frames tarde en salir de su hitbox.
Para evitar esto he implementado un Estado "hit" al enemigo como una flag que se activa a la primera colisión, recibe el daño al no estar activado previamente, pero a los frames consecutivos, si hit == true, no recibe daño. La flag se desactiva cuando en cualquier frame no reconozca ninguna colisión, entonces podrá volver a recibir daño en la próxima colisión.
No es la mejor solución ya que implica que si dos proyectiles lo atraviesan a la vez solo reciba el daño del primero, pero es la mejor solución que he conseguido.

Además cada proyectil tiene un contador llamado Pierce (penetración), que se ve reducido cada vez que golpea un enemigo, y la solución anterior ayuda a que no se reduzca por cada frame colisionando, sino por cada vez que atraviese un enemigo. Una vez llega a 0 desaparece, o cuando el número de proyectiles vivos supera 
(ceil(atkSpd * range / prjSpd) + prjPierce), para que no dure eternamente. Está pensada la ecuación para que dependiendo del tiempo en el que un proyectil pueda recorrer el radio de su rango, pueda recorrerlo siempre, y tenga un pequeño margen tras recorrerlo de sobra, además de aumentar con su Pierce.
Con esto me aseguro de que hay un límite de proyectiles en pantalla que no suponga un bajón de rendimiento.

![rango](https://user-images.githubusercontent.com/72341309/123550820-93721100-d76f-11eb-86d0-d850f1ec37f0.png)

